<!-- question-type: inclass -->
### Exercise 4: What's Missing? Understanding Joins by Seeing What They Drop

In Exercise 2, we used `left_join()` to combine data from different tables â€” like firm details, subindustry names, and P/E ratios. That helped us build one data frame with all the information in one place. Now, we'll go a step further and explore what different kinds of joins keep and drop. This can help us spot missing or underrepresented data â€” and understand our dataset more deeply.

**(a)**.
Let's start by counting how many firms in the ASX200 belong to each subindustry. Use the starter code below to return the three most common industries: 

```{r}
#| eval: false

firm_info |> 
    YOUR_CODE(subind) |> 
    YOUR_CODE(desc(n)) |> 
    YOUR_CODE(3)
```

And, now the three least common:

```{r}
#| eval: false

firm_info |> 
    YOUR_CODE(subind) |> 
    YOUR_CODE((n)) |> 
    YOUR_CODE(3)
```

**(b)**. Are there any subindustries that donâ€™t appear in the ASX200 sample-and so are even less common those that we identify in (a)?

We can use `anti_join()` to find subindustries listed in `subindustry_names` but missing from our firms data. How many subindustries are not included in the ASX200?

```{r}
#| eval: false

YOUR_CODE |> 
    YOUR_CODE(firm_info, by = "subind") |> 
    nrow()
```

**(c)**. What kinds of industries are missing? Why might they be underrepresented in the ASX200?

**(d)**. An `inner_join()` keeps only the firms that have a matching subindustry in the lookup table. Recreate the join you did in Exercise 2(a), but this time use `inner_join()` instead of `left_join()`.

```{r}
#| eval: false

firm_info_inner <- 
    firm_codes |>
    YOUR_CODE(subindustry_names, by = "gsubind")
```

**(e)** Are there any differences in the dataframe in (d) to the one you constructed in 2 (a)? Explain your answer.

**(f)**. Over this exercise and Exercise 2, you've used three different types of joins:

* `left_join()`
* `anti_join()`
* `inner_join()`

Each one gives you a slightly different view of how your data frames relate to each other.

In your own words, answer the following:

1. What does each join keep and what does it drop?
2. Which join is most useful when you want to preserve all rows from one table, even if they donâ€™t match?
3. Which join is best for finding mismatches between two tables?
4. Which join only keeps perfect matches between the two tables?


<!-- BEGIN PROFILE:r-teaching-guide -->
::: {.content-visible when-profile="r-teaching-guide"}

::: {.teaching-block}

::: {.teaching-block-header}
Teaching Note
:::

::: {.teaching-block-body}

ðŸŽ¯ **Learning Objective** 
Students should:

- XXXXX

âœ…   **Core Concepts to Highlight**

List them here


ðŸ’¬ **Suggested In-Class Prompts** (if needed)

List as needed

ðŸ“Œ **Common Misunderstandings**

List as needed

:::

:::

:::
<!-- END PROFILE:r-teaching-guide -->

<!-- BEGIN PROFILE:r-solutions -->
::: {.content-visible when-profile="r-solutions" when-profile="r-teaching-guide"}

::: {.solution-block}

::: {.solution-block-header}
Solution
:::

::: {.solution-block-body}

**(a).**

```{r}
firm_info |> 
    count(subind) |> 
    arrange(desc(n)) |> 
    head(3)
```

```{r}
firm_info |> 
    count(subind) |> 
    arrange(n) |> 
    head(3)
```

**(b).** 

```{r}
subindustry_names |> 
    anti_join(firm_info, by = "subind") |> 
    nrow()
```

This tells us how many subindustries are not represented in the ASX200 sample â€” i.e., they appear in the lookup table but not among the top 200 firms.

**(c).**

Look through this output and see if there's any common themes...

```{r}
subindustry_names |> 
    anti_join(firm_info, by = "subind") 
```

**(d)**.

```{r}
firm_info_inner <- 
    firm_codes |>
    inner_join(subindustry_names, by = "gsubind")

firm_info_inner
```

**(e)**. 
The difference is subtle, but if all gsubind codes in `firm_codes` matched a subindustry in the lookup table, then the result will look identical to the `left_join()` output from Exercise 2.

However, if there were any firms with a gsubind code that did not match a code in subindustry_names, those rows would be dropped in the `inner_join()` version but retained (with NA in subind) in the `left_join()`.

Let's see what these are (and re-inforce what `anti_join()` does):

```{r}
firm_info %>%
    anti_join(firm_info_inner, by = "gsubind")
```

This is equivalent to:

```{r}
firm_info |> 
    anti_join(subindustry_names, by = "subind") 
```

We can confirm that this is a case of a gsubind that we don't get a match on in our lookup table:

```{r}
subindustry_names |>
    filter(gsubind == "45101010")
```

**(f).**

1. What does each join keep and drop?

`left_join(x, y)`

* Keeps all rows from x, adds columns from y where there's a match; unmatched rows get NAs.

`inner_join(x, y)`

* Keeps only rows in x that have a match in y (i.e., the intersection).

`anti_join(x, y)`

* Keeps only rows in x that donâ€™t match any row in y.


2. Which join helps preserve all rows from one table?

`left_join()`


3. Which join is best for finding mismatches?

`anti_join()`


4. Which join only keeps complete matches?

`inner_join()`

:::

:::

:::
<!-- END PROFILE:r-solutions -->