<!-- question-type: inclass -->
### Exercise 4: Using joins to identify missing values, implicit or otherwise

In Exercise 2, we wrangled and joined several data frames to create a single data frame that provides yearly price earnings ratios for large ASX-listed firms for the period 2005-2024. We also added to this data frame a column that identifies each firm‚Äôs sub-industry. In doing so, we got a feel for using `left_join()` and a sense for the role that primary and foreign keys play in matching and combining observations across data frames.

At the end of this exercise, you will use the data frame that you created in Exercise 2 to produce the following plot:

```{r}
#| echo: false

sub_sample <- c(
  "Diversified Metals & Mining", "Gold",
  "Construction & Engineering"
)

sub_ind_pe <- 
  pe_subindustries |>
  filter(subind %in% sub_sample) |>
  filter(fyear <= 2019) |>
  group_by(subind, fyear) |>
  summarise(ave_pe = mean(pe, na.rm = TRUE),
            .groups = "drop"
  )

year_range <- range(sub_ind_pe$fyear)

breaks_seq <- seq(from = year_range[1], to = year_range[2], by = 2)

sub_ind_pe |>
  ggplot(aes(x = fyear, y = ave_pe, color = subind)) +
  geom_line(size = 0.75) +
  labs(
    title = "Average P/E Ratios",
    subtitle = "Most common subindustries among large Australian firms",
    x = "Year",
    y = "Average P/E Ratio",
    color = "Subindustry"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    legend.position = "bottom"
  ) +
  scale_color_okabe_ito() +                 
  scale_x_continuous(breaks = breaks_seq) +
  scale_y_continuous(limits = c(0, 110))
```

However, before we get to the task of producing this plot, we will first examine how different types of joins add or remove rows from a data frame, and so shed light on where different data frames overlap and how this can reveal missing values, implicit or otherwise.

**(a).** To begin, let‚Äôs return to the data frame that we created in Exercise 2(a), where we used a join function to identify each firm‚Äôs sub-industry for our sample of the 200-largest ASX-listed firms in 2024. 

```{r}
#| echo: false

firms_subindustries |>
  head(10)
```

Based on this data frame, which sub-industries are most common in our sample of large firms? Which sub-industries are least common? 

To answer these questions, use the starter code below to produce a table that provides the count of observations for each sub-industry in our sample.

```{r}
#| eval: false

firms_subindustries |>
  YOUR_FUNCTION_NAME(subind) |>
  YOUR_FUNCTION_NAME() |>
  arrange(desc(count))
```

**(b).** We can employ filtering joins on the component data frames that we combined to create the data frame above to shed further light on the composition of our sample. Let's start by using an anti-join. 

Run the code below: 

```{r}
#| eval: false

anti_join_df <-  subind_names |>
  anti_join(firms_subind_codes)

anti_join_df
```

Explain in your own words which rows are stored in the output data frame. Why does the table in Exercise 4(a) fail to capture the existence of these sub-industries? If we want to understand which sub-industries are underrepresented among large Australian public companies, what does this new data frame reveal?

**(c).** Let's stick with anti-joins for a bit longer. Now, use the starter code below to flip the ordering of the data frames that you joined in the task above (i.e., `anti_join(x,y)` should now be `anti_join(y,x)`: 

```{r}
#| eval: false

reversed_anti_join_df <-  YOUR_DATAFRAME_NAME %>%
  YOUR_FUNCTION_NAME(YOUR_DATAFRAME_NAME)
```

Explain in your own words which rows are stored in the output data frame. What does this data frame reveal about whether we are able to identify the sub-industry for the vast majority of firms in our sample?

**(d).** Now, let's play around with inner-joins. Run the chunk of code below: 

```{r}
#| eval: false

inner_join_df <- subind_names %>%
  inner_join(firms_subind_codes)

inner_join_df
```

Explain in your own words which rows are stored in the output data frame. Reconcile the rows in this new data frame to those in the data frame you produced above in Exercise 4(c).

**(e).** During the lecture and tutorial preparation tasks, we went through all this effort to join our data on firms' sub-industry and price-earnings ratios. And so, to conclude let's visualize our data to examine the following: Among the three most-common sub-industries in our sample, how did average price-earnings ratios behave historically prior to the COVID-19 pandemic? 

Use the starter code below to produce the plot that follows:

```{r}
#| eval: false

sub_sample <- c(
  "Diversified Metals & Mining", "Gold",
  "Construction & Engineering"
)

sub_ind_pe <- 
  YOUR_DATAFRAME_NAME |>
  YOUR_FUNCTION_NAME(subind %in% sub_sample) |>
  YOUR_FUNCTION_NAME(fyear <= 2019) |>
  group_by(YOUR_VARIABLE_NAME, YOUR_VARIABLE_NAME) |>
  YOUR_FUNCTION_NAME(ave_pe = YOUR_FUNCTION_NAME())

year_range <- 
  range(sub_ind_pe$fyear)

breaks_seq <- 
  seq(from = year_range[1], 
      to = year_range[2], 
      by = 2
  )

sub_ind_pe |>
  ggplot(aes(x = fyear, y = ave_pe, color = subind)) +
    geom_line(size = 0.75) +
    labs(
        title = "Average P/E Ratios",
        subtitle = "Most common subindustries among large Australian firms",
        x = "Year",
        y = "Average P/E Ratio",
        color = "Subindustry"
    ) +
    theme_minimal(base_size = 13) +
    theme(
        plot.title = element_text(face = "bold", size = 15),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(face = "bold"),
        legend.position = "bottom"
    ) +
  scale_color_okabe_ito() +                 
  scale_x_continuous(breaks = breaks_seq) +
  scale_y_continuous(limits = c(0, 110))
```

```{r}
#| echo: false

sub_sample <- c(
  "Diversified Metals & Mining", "Gold",
  "Construction & Engineering"
)

sub_ind_pe <- 
  pe_subindustries |>
  filter(subind %in% sub_sample) |>
  filter(fyear <= 2019) |>
  group_by(subind, fyear) |>
  summarise(ave_pe = mean(pe, na.rm = TRUE),
            .groups = "drop"
  )

year_range <- 
  range(sub_ind_pe$fyear)

breaks_seq <- 
  seq(from = year_range[1], 
      to = year_range[2], 
      by = 2
  )

sub_ind_pe |>
  ggplot(aes(x = fyear, y = ave_pe, color = subind)) +
    geom_line(size = 0.75) +
    labs(
        title = "Average P/E Ratios",
        subtitle = "Most common subindustries among large Australian firms",
        x = "Year",
        y = "Average P/E Ratio",
        color = "Subindustry"
    ) +
    theme_minimal(base_size = 13) +
    theme(
        plot.title = element_text(face = "bold", size = 15),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(face = "bold"),
        legend.position = "bottom"
    ) +
  scale_color_okabe_ito() +                 
  scale_x_continuous(breaks = breaks_seq) +
  scale_y_continuous(limits = c(0, 110))
```

**(f).** Using the above plot, answer the following: 

- How do price-earnings ratios vary across industries? And over time? 

- Do we observe a common trend across subindustries or do observe differences in trends? 

- What economic stories can we tell to explain this plot? 

- Mechanically, what are the drivers of an increasing P/E ratio? And a decreasing P/E ratio?

<!-- BEGIN PROFILE:r-teaching-guide -->
::: {.content-visible when-profile="r-teaching-guide"}

::: {.teaching-block}

::: {.teaching-block-header}
Teaching Note
:::

::: {.teaching-block-body}

üéØ **Learning Objective** 
Students should:

- XXXXX

‚úÖ   **Core Concepts to Highlight**

List them here


üí¨ **Suggested In-Class Prompts** (if needed)

List as needed

üìå **Common Misunderstandings**

List as needed

:::

:::

:::
<!-- END PROFILE:r-teaching-guide -->

<!-- BEGIN PROFILE:r-solutions -->
::: {.content-visible when-profile="r-solutions" when-profile="r-teaching-guide"}

::: {.solution-block}

::: {.solution-block-header}
Solution
:::

::: {.solution-block-body}

**(a). Industry coverage in our sample**

Here's the updated code here:

```{r}
# Start from firm‚Äìsubindustry dataset
firms_subindustries |>
  # Group firms by subindustry
  group_by(subind) |>
  # Count how many rows (firms) are in each subindustry
  summarise(count = n()) |>
  # Arrange subindustries in descending order of firm count
  arrange(desc(count))
```

In our sample, firms from the Diversified Metals & Mining, Gold, and Construction & Engineering sub-industries are most common. There are many sub-industries that account for only a single firm in our sample-e.g., Pharmaceuticals, Specialty Chemicals, etc.

**(b). Anti-join to identify missing sub-industries**

An anti-join returns the rows from the first data frame (`subind_names`) that do not have a matching key (`gsubind`) in the second data frame (`firms_subind_codes`). In other words: it gives us all sub-industries defined in the classification system that are not represented by any of the ASX 200 firms in our sample.

In Exercise 2(a), when we joined `firms_subind_codes` with `subind_names`, the output only included sub-industries that actually had at least one firm in the ASX 200. This meant sub-industries with no large listed firms simply didn‚Äôt appear in the table. The join ignored them because there were no matches on the key (`gsubind`).

`anti_join_df` highlights the underrepresented or absent sub-industries in the ASX 200. These rows tell us: ‚ÄúHere are sectors that exist in the economy (according to GICS), but no top-200 ASX firm belongs to them.‚Äù

**(c). Reversed anti-join to identify represented sub-industries**

Here's the updated code:

```{r}
# Perform an anti-join: keep rows in firms_subind_codes 
# that do not have a matching subindustry in subind_names
reversed_anti_join_df <- 
  firms_subind_codes |>
  anti_join(subind_names)

# Display the resulting dataset
reversed_anti_join_df
```

This anti_join in the opposite direction returns firms from `firms_subind_codes` whose `gsubind` does not have a match in the `subind_names` lookup table. In other words, these are firms with missing or invalid sub-industry codes (e.g., a code not present in the GICS sub-industry reference, a data entry error, or a genuinely missing code).

In a clean data set, `reversed_anti_join_df` should be empty or very small, indicating that almost all firms‚Äô `gsubind` codes do match a valid sub-industry name in `subind_names`. If this table contains many rows, it flags a data quality issue (e.g., stale codes, typos, or incomplete mapping) that should be investigated and cleaned before further analysis. We observe that our data frame does not contain any rows, which suggests that we are able to identify the sub-industry for the vast majority of firms in our sample.

**(d). Inner-join to identify represented sub-industries**

An inner join keeps only rows where the join key (`gsubind`) appears in both data frames. In this case, it returns all sub-industries that:

- Exist in the sub-industry lookup table (`subind_names`), and

- Have at least one firm among the ASX 200 (`firms_subind_codes`)


So the output excludes:

- Sub-industries that have no ASX 200 firms (those appeared in the earlier anti-join from `subind_names`).

- Firms whose `gsubind` doesn‚Äôt match a valid sub-industry code (those appeared in the reversed anti-join).


While anti_join_df from Exercise 4(c) showed sub-industries missing from the ASX 200 (present in the classification but with no firms), the data frame from the inner join is essentially the complement: it shows the sub-industries that are represented in the ASX 200.

**(e). Visualizing average P/E ratios by sub-industry**

Here's the updated code:

```{r}
# Choose three subindustries to focus on
sub_sample <- c(
  "Diversified Metals & Mining", 
  "Gold",
  "Construction & Engineering"
)

# Compute average P/E ratios for chosen subindustries, by year up to 2019
sub_ind_pe <- 
  pe_subindustries |>
  # Keep only selected subindustries
  filter(subind %in% sub_sample) |>  
  # Restrict to years up to 2019
  filter(fyear <= 2019) |>  
  # Group by subindustry and year
  group_by(subind, fyear) |>  
  # Calculate mean P/E per group
  summarise(
    ave_pe = mean(pe, na.rm = TRUE),
    .groups = "drop"
  )

# Work out range of years to set x-axis limits
year_range <- range(sub_ind_pe$fyear)

# Generate tick marks every 2 years for x-axis
breaks_seq <- seq(from = year_range[1], 
                  to   = year_range[2], 
                  by   = 2)

# Plot average P/E ratios over time
sub_ind_pe |>
  ggplot(aes(x = fyear, y = ave_pe, color = subind)) +
  # Draw lines for each subindustry
  geom_line(size = 0.75) +
  # Add labels for title, subtitle, and axes
  labs(
    title    = "Average P/E Ratios",
    subtitle = "Most common subindustries among large Australian firms",
    x        = "Year",
    y        = "Average P/E Ratio",
    color    = "Subindustry"
  ) +
  # Apply a clean minimal theme
  theme_minimal(base_size = 13) +
  # Style plot title, axis titles, and legend
  theme(
    plot.title   = element_text(face = "bold", size = 15),
    axis.title   = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    legend.position = "bottom"
  ) +
  # Apply Okabe‚ÄìIto colorblind-friendly palette
  scale_color_okabe_ito() +
  # Set x-axis ticks every 2 years
  scale_x_continuous(breaks = breaks_seq) +
  # Fix y-axis range
  scale_y_continuous(limits = c(0, 110))
```

**(f). Interpreting the plot**

Variation Across Industries:

- Gold and Diversified Metals have the highest average P/E ratios.

- Construction and Engineering has the lowest average P/E ratios, indicating more stable earnings relative to share prices.

Variation Over Time

- Gold mining firms show the most volatility, with sharp spikes and drops, reflecting the role of gold as a safe-haven asset during financial stress (e.g., GFC in 2008).

- Diversified Metals & Mining also display cyclical fluctuations tied to global commodity cycles.

- Construction & Engineering remains relatively stable, reflecting steadier domestic demand.

- There is no common trend across sub-industries. Instead, we see industry-specific cycles: gold and mining rise and fall with commodity prices, while construction moves more smoothly.

Economic Stories

- Gold spikes reflect investor demand for safe-haven assets when uncertainty is high.

- Metals & Mining swings capture boom-and-bust cycles in global demand and commodity pricing.

- Construction‚Äôs stability is linked to consistent infrastructure and domestic projects (trending upward due to recent, large-scale government projects).

Mechanical Drivers

- Increasing P/E ratio: Share prices rise faster than earnings, or earnings collapse while prices hold steady.

- Decreasing P/E ratio: Earnings rise faster than prices, or prices fall relative to earnings.

:::

:::

:::
<!-- END PROFILE:r-solutions -->